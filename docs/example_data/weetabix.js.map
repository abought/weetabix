{"version":3,"sources":["../node_modules/comma-separated-values/csv.js","weetabix.js"],"names":["CategoryReader","BaseReader","source_url","index","_source","_index_src","_delimiter","_index","_ready","loader","fetch","then","resp","ok","json","Error","Promise","resolve","contents","delimiter","value","options","strict","entry","_findValue","start","end","headers","Object","assign","status","text","data","CSV","parse","cellDelimiter","cast","keys"],"mappings":"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","file":"weetabix.js","sourceRoot":"../src","sourcesContent":["(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    root.CSV = factory();\n  }\n}(this, function() {\n  'use strict';\n\n  var ESCAPE_DELIMITERS = ['|', '^'],\n      CELL_DELIMITERS = [',', ';', '\\t', '|', '^'],\n      LINE_DELIMITERS = ['\\r\\n', '\\r', '\\n'];\n\n  function isObject(object) {\n    var type = typeof object;\n    return type === 'function' || type === 'object' && !!object;\n  }\n  var isArray = Array.isArray || function(object) {\n    return toString.call(object) === '[object Array]';\n  }\n  function isString(object) {\n    return typeof object === 'string';\n  }\n  function isNumber(object) {\n    return !isNaN(Number(object));\n  }\n  function isBoolean(value) {\n    return value == false || value == true;\n  }\n  function isNull(value) {\n    return value == null;\n  }\n  function isPresent(value) {\n    return value != null;\n  }\n\n  function fallback(value, fallback) {\n    return isPresent(value) ? value : fallback;\n  }\n\n  function forEach(collection, iterator) {\n    for (var _i = 0, _len = collection.length; _i < _len; _i += 1) {\n      if (iterator(collection[_i], _i) === false) break;\n    }\n  }\n\n  function sanitizeString(string) {\n    return string.replace(/\"/g,'\\\\\"');\n  }\n\n  function buildCell(index) {\n    return 'attrs[' + index + ']';\n  }\n\n  function castCell(value, index) {\n    if (isNumber(value)) {\n      return 'Number(' + buildCell(index) + ')';\n    } else if (isBoolean(value)) {\n      return 'Boolean(' + buildCell(index) + ' == true)';\n    } else {\n      return 'String(' + buildCell(index) + ')';\n    }\n  }\n\n  function buildConstructor(deserialize, cast, values, attrs) {\n    var definition = [];\n    if (arguments.length == 3) {\n      if (cast) {\n        if (isArray(cast)) {\n          forEach(values, function(value, index) {\n            if (isString(cast[index])) {\n              cast[index] = cast[index].toLowerCase();\n            } else {\n              deserialize[cast[index]] = cast[index];\n            }\n            definition.push('deserialize[cast[' + index + ']](' + buildCell(index) + ')');\n          });\n        } else {\n          forEach(values, function(value, index) {\n            definition.push(castCell(value, index));\n          });\n        }\n      } else {\n        forEach(values, function(value, index) {\n          definition.push(buildCell(index));\n        });\n      }\n      definition = 'return [' + definition.join(',') + ']';\n    } else {\n      if (cast) {\n        if (isArray(cast)) {\n          forEach(values, function(value, index) {\n            if (isString(cast[index])) {\n              cast[index] = cast[index].toLowerCase();\n            } else {\n              deserialize[cast[index]] = cast[index];\n            }\n            definition.push('\"' + sanitizeString(attrs[index]) + '\": deserialize[cast[' + index + ']](' + buildCell(index) + ')');\n          });\n        } else {\n          forEach(values, function(value, index) {\n            definition.push('\"' + sanitizeString(attrs[index]) + '\": ' + castCell(value, index));\n          });\n        }\n      } else {\n        forEach(values, function(value, index) {\n          definition.push('\"' + sanitizeString(attrs[index]) + '\": ' + buildCell(index));\n        });\n      }\n      definition = 'return {' + definition.join(',') + '}';\n    }\n    return new Function('attrs', 'deserialize', 'cast', definition);\n  }\n\n  function detectDelimiter(string, delimiters) {\n    var count = 0,\n        detected;\n\n    forEach(delimiters, function(delimiter) {\n      var needle = delimiter,\n          matches;\n      if (ESCAPE_DELIMITERS.indexOf(delimiter) != -1) {\n        needle = '\\\\' + needle;\n      }\n      matches = string.match(new RegExp(needle, 'g'));\n      if (matches && matches.length > count) {\n        count = matches.length;\n        detected = delimiter;\n      }\n    });\n    return (detected || delimiters[0]);\n  }\n\n  var CSV = (function() {\n    function CSV(data, options) {\n      if (!options) options = {};\n\n      if (isArray(data)) {\n        this.mode = 'encode';\n      } else if (isString(data)) {\n        this.mode = 'parse';\n      } else {\n        throw new Error(\"Incompatible format!\");\n      }\n\n      this.data = data;\n\n      this.options = {\n        header: fallback(options.header, false),\n        cast: fallback(options.cast, true)\n      }\n\n      var lineDelimiter = options.lineDelimiter || options.line,\n          cellDelimiter = options.cellDelimiter || options.delimiter;\n\n      if (this.isParser()) {\n        this.options.lineDelimiter = lineDelimiter || detectDelimiter(this.data, LINE_DELIMITERS);\n        this.options.cellDelimiter = cellDelimiter || detectDelimiter(this.data, CELL_DELIMITERS);\n        this.data = normalizeCSV(this.data, this.options.lineDelimiter);\n      } else if (this.isEncoder()) {\n        this.options.lineDelimiter = lineDelimiter || '\\r\\n';\n        this.options.cellDelimiter = cellDelimiter || ',';\n      }\n    }\n\n    function invoke(method, constructor, attributes, deserialize, cast) {\n      method(new constructor(attributes, deserialize, cast));\n    }\n\n    function normalizeCSV(text, lineDelimiter) {\n      if (text.slice(-lineDelimiter.length) != lineDelimiter) text += lineDelimiter;\n      return text;\n    }\n\n    CSV.prototype.set = function(setting, value) {\n      return this.options[setting] = value;\n    }\n\n    CSV.prototype.isParser = function() {\n      return this.mode == 'parse';\n    }\n\n    CSV.prototype.isEncoder = function() {\n      return this.mode == 'encode';\n    }\n\n    CSV.prototype.parse = function(callback) {\n      if (this.mode != 'parse') return;\n      if (this.data.trim().length === 0) return [];\n\n      var data = this.data,\n          options = this.options,\n          header = options.header,\n          current = { cell: '', line: [] },\n          deserialize = this.deserialize,\n          flag, record, response;\n\n      if (!callback) {\n        response = [];\n        callback = function(record) {\n          response.push(record);\n        }\n      }\n\n      function resetFlags() {\n        flag = { escaped: false, quote: false, cell: true };\n      }\n      function resetCell() {\n        current.cell = '';\n      }\n      function resetLine() {\n        current.line = [];\n      }\n\n      function saveCell(cell) {\n        current.line.push(flag.escaped ? cell.slice(1, -1).replace(/\"\"/g, '\"') : cell);\n        resetCell();\n        resetFlags();\n      }\n      function saveLastCell(cell) {\n        saveCell(cell.slice(0, 1 - options.lineDelimiter.length));\n      }\n      function saveLine() {\n        if (header) {\n          if (isArray(header)) {\n            record = buildConstructor(deserialize, options.cast, current.line, header);\n            saveLine = function() {\n              invoke(callback, record, current.line, deserialize, options.cast);\n            };\n            saveLine();\n          } else {\n            header = current.line;\n          }\n        } else {\n          if (!record) {\n            record = buildConstructor(deserialize, options.cast, current.line);\n          }\n          saveLine = function() {\n            invoke(callback, record, current.line, deserialize, options.cast);\n          };\n          saveLine();\n        }\n      }\n\n      if (options.lineDelimiter.length == 1) saveLastCell = saveCell;\n\n      var dataLength = data.length,\n          cellDelimiter = options.cellDelimiter.charCodeAt(0),\n          lineDelimiter = options.lineDelimiter.charCodeAt(options.lineDelimiter.length - 1),\n          _i, _c, _ch;\n\n      resetFlags();\n\n      for (_i = 0, _c = 0; _i < dataLength; _i++) {\n        _ch = data.charCodeAt(_i);\n\n        if (flag.cell) {\n          flag.cell = false;\n          if (_ch == 34) {\n            flag.escaped = true;\n            continue;\n          }\n        }\n\n        if (flag.escaped && _ch == 34) {\n          flag.quote = !flag.quote;\n          continue;\n        }\n\n        if ((flag.escaped && flag.quote) || !flag.escaped) {\n          if (_ch == cellDelimiter) {\n            saveCell(current.cell + data.slice(_c, _i));\n            _c = _i + 1;\n          } else if (_ch == lineDelimiter) {\n            saveLastCell(current.cell + data.slice(_c, _i));\n            _c = _i + 1;\n            if (current.line.length > 1 || current.line[0] !== \"\") {\n              saveLine();\n            }\n            resetLine();\n          }\n        }\n      }\n\n      if (response) {\n        return response;\n      } else {\n        return this;\n      }\n    }\n\n    function serializeType(object) {\n      if (isArray(object)) {\n        return 'array';\n      } else if (isObject(object)) {\n        return 'object';\n      } else if (isString(object)) {\n        return 'string';\n      } else if (isNull(object)) {\n        return 'null';\n      } else {\n        return 'primitive';\n      }\n    }\n\n    CSV.prototype.deserialize = {\n      \"string\": function(string) {\n        return String(string);\n      },\n      \"number\": function(number) {\n        return Number(number);\n      },\n      \"boolean\": function(b) {\n        return Boolean(b);\n      }\n    }\n\n    CSV.prototype.serialize = {\n      \"object\": function(object) {\n        var that = this,\n            attributes = Object.keys(object),\n            serialized = Array(attributes.length);\n        forEach(attributes, function(attr, index) {\n          serialized[index] = that[serializeType(object[attr])](object[attr]);\n        });\n        return serialized;\n      },\n      \"array\": function(array) {\n        var that = this,\n            serialized = Array(array.length);\n        forEach(array, function(value, index) {\n          serialized[index] = that[serializeType(value)](value);\n        });\n        return serialized;\n      },\n      \"string\": function(string) {\n        return '\"' + String(string).replace(/\"/g, '\"\"') + '\"';\n      },\n      \"null\": function(value) {\n        return '';\n      },\n      \"primitive\": function(value) {\n        return value;\n      }\n    }\n\n    CSV.prototype.encode = function(callback) {\n      if (this.mode != 'encode') return;\n\n      if (this.data.length == 0) return '';\n\n      var data = this.data,\n          options = this.options,\n          header = options.header,\n          sample = data[0],\n          serialize = this.serialize,\n          offset = 0,\n          attributes, response;\n\n      if (!callback) {\n        response = Array(data.length);\n        callback = function(record, index) {\n          response[index + offset] = record;\n        }\n      }\n\n      function serializeLine(record) {\n        return record.join(options.cellDelimiter);\n      }\n\n      if (header) {\n        if (!isArray(header)) {\n          attributes = Object.keys(sample);\n          header = attributes;\n        }\n        callback(serializeLine(serialize.array(header)), 0);\n        offset = 1;\n      }\n\n      var recordType = serializeType(sample),\n          map;\n\n      if (recordType == 'array') {\n        if (isArray(options.cast)) {\n          map = Array(options.cast.length);\n          forEach(options.cast, function(type, index) {\n            if (isString(type)) {\n              map[index] = type.toLowerCase();\n            } else {\n              map[index] = type;\n              serialize[type] = type;\n            }\n          });\n        } else {\n          map = Array(sample.length);\n          forEach(sample, function(value, index) {\n            map[index] = serializeType(value);\n          });\n        }\n        forEach(data, function(record, recordIndex) {\n          var serializedRecord = Array(map.length);\n          forEach(record, function(value, valueIndex) {\n            serializedRecord[valueIndex] = serialize[map[valueIndex]](value);\n          });\n          callback(serializeLine(serializedRecord), recordIndex);\n        });\n      } else if (recordType == 'object') {\n        attributes = Object.keys(sample);\n        if (isArray(options.cast)) {\n          map = Array(options.cast.length);\n          forEach(options.cast, function(type, index) {\n            if (isString(type)) {\n              map[index] = type.toLowerCase();\n            } else {\n              map[index] = type;\n              serialize[type] = type;\n            }\n          });\n        } else {\n          map = Array(attributes.length);\n          forEach(attributes, function(attr, index) {\n            map[index] = serializeType(sample[attr]);\n          });\n        }\n        forEach(data, function(record, recordIndex) {\n          var serializedRecord = Array(attributes.length);\n          forEach(attributes, function(attr, attrIndex) {\n            serializedRecord[attrIndex] = serialize[map[attrIndex]](record[attr]);\n          });\n          callback(serializeLine(serializedRecord), recordIndex);\n        });\n      }\n\n      if (response) {\n        return response.join(options.lineDelimiter);\n      } else {\n        return this;\n      }\n    }\n\n    CSV.prototype.forEach = function(callback) {\n      return this[this.mode](callback);\n    }\n\n    return CSV;\n  })();\n\n  CSV.parse = function(data, options) {\n    return new CSV(data, options).parse();\n  }\n\n  CSV.encode = function(data, options) {\n    return new CSV(data, options).encode();\n  }\n\n  CSV.forEach = function(data, options, callback) {\n    if (arguments.length == 2) {\n      callback = options;\n    }\n    return new CSV(data, options).forEach(callback);\n  }\n\n  return CSV;\n}));\n","/**\n * Use a weetabix format index\n */\n\nimport CSV from 'comma-separated-values';\n\nclass BaseReader {\n    constructor(source_url, { index = null } = {}) {\n        this._source = source_url;\n        this._index_src = index || `${source_url}.wtb`;\n\n        // Information to read from the index (once ready)\n        this._delimiter = null;\n        this._index = null;\n        this._ready = false;\n    }\n\n    /**\n     * Load the index file from the specified source. Returns a promise that will resolve when the reader is ready to\n     *  use.\n     * @returns {Promise<Reader | never>}\n     */\n    prepare() {\n        // Load data from the index, and return a promise\n        let loader;\n        if (typeof this._index_src === 'string') {\n            loader = fetch(this._index_src).then(resp => {\n                if (resp.ok) {\n                    return resp.json();\n                } else {\n                    throw new Error(`Index could not be read from ${this._index_src}`);\n                }\n            });\n        } else {\n            // Allows specifying the index inline with the page, rather than as a separate download\n            loader = Promise.resolve(this._index_src);\n        }\n\n        return loader.then(contents => {\n            this._delimiter = contents.delimiter;\n            this._index = contents.index;\n            this._ready = true;\n            return this;\n        });\n    }\n\n    /**\n     * Fetch the section of the file containing the data of interest\n     * @param value The category of name to retrieve from the index\n     * @param options Arguments to be passed to the network request. See JS \"fetch\" documentation for details.\n     * @param strict\n     * @returns {Promise<Array[]>}\n     */\n    fetch(value, { options = {}, strict = true } = {}) {\n        const entry = this._findValue([value]);\n        if (!entry && !strict) {\n            return Promise.resolve([]);\n        } else if (!entry) {\n            throw new Error('The index has no information about the requested item');\n        }\n        const [start, end] = entry;\n\n        options.headers = Object.assign({\n            'Accept-Encoding': 'identity',  // Don't try to use gzip + byte range at same time\n            'Range': `bytes=${start}-${end - 1}`\n        }, (options.headers || {}));\n\n        return fetch(this._source, options).then(resp => {\n            if (!resp.ok || resp.status !== 206) {\n                // Safeguard: do not parse unless the server indicates it is responding to a partial request.\n                //   Some web hosts (and many local development tools) do not properly support range headers!\n                throw new Error('Could not successfully request partial data');\n            }\n            return resp.text();\n        }).then(data => CSV.parse(data, {cellDelimiter: this._delimiter, cast: false}));\n    }\n\n    /////// Most reader subclasses will involve a different index format, and will only need to override the methods\n    //  below this line.\n    /**\n     * Search the index for a desired value. Default implementation looks for exact match as key name.\n     * @param value\n     * @returns [] The start and end coordinates (or null if item not in index)\n     * @private\n     */\n    _findValue(value) {\n        return this._index[value];\n    }\n\n    getEntries() {\n        if (!this._ready) {\n            throw new Error('Index data has not yet been loaded.');\n        }\n        return Object.keys(this._index);\n    }\n}\n\n\n// For now a category reader is the only kind; this may change.\nclass CategoryReader extends BaseReader {}\n\nexport default CategoryReader;\nexport { CategoryReader, BaseReader };\n"]}